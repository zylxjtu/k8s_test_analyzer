"""
JUnit XML parser for Kubernetes e2e test results.

Parses JUnit XML files generated by Kubernetes e2e tests and extracts
test results, failures, and error information.
"""

import logging
import re
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Optional, Union

from .models import TestCase, TestSuite, TestStatus

logger = logging.getLogger(__name__)


class JUnitParser:
    """Parser for JUnit XML test result files."""
    
    def __init__(self):
        pass
    
    def parse_file(self, file_path: Union[str, Path]) -> list[TestSuite]:
        """
        Parse a JUnit XML file and return test suites.
        
        Args:
            file_path: Path to JUnit XML file
            
        Returns:
            List of TestSuite objects
        """
        file_path = Path(file_path)
        
        if not file_path.exists():
            logger.error(f"JUnit file not found: {file_path}")
            return []
        
        try:
            content = file_path.read_text(errors='replace')
            return self.parse_xml(content)
        except Exception as e:
            logger.error(f"Failed to parse JUnit file {file_path}: {e}")
            return []
    
    def parse_xml(self, xml_content: str) -> list[TestSuite]:
        """
        Parse JUnit XML content.
        
        Args:
            xml_content: JUnit XML as string
            
        Returns:
            List of TestSuite objects
        """
        try:
            # Handle potential encoding issues
            xml_content = self._sanitize_xml(xml_content)
            root = ET.fromstring(xml_content)
            
            suites = []
            
            # Handle both <testsuites> and single <testsuite> root
            if root.tag == 'testsuites':
                for suite_elem in root.findall('testsuite'):
                    suite = self._parse_testsuite(suite_elem)
                    if suite:
                        suites.append(suite)
            elif root.tag == 'testsuite':
                suite = self._parse_testsuite(root)
                if suite:
                    suites.append(suite)
            else:
                logger.warning(f"Unexpected root element: {root.tag}")
            
            return suites
            
        except ET.ParseError as e:
            logger.error(f"XML parse error: {e}")
            return []
    
    def _sanitize_xml(self, content: str) -> str:
        """Clean up XML content to handle common issues."""
        # Remove invalid XML characters
        content = re.sub(r'[\x00-\x08\x0b\x0c\x0e-\x1f]', '', content)
        # Handle CDATA issues
        content = content.replace(']]>]]>', ']]]]><![CDATA[>')
        return content
    
    def _parse_testsuite(self, elem: ET.Element) -> Optional[TestSuite]:
        """Parse a testsuite element."""
        try:
            suite = TestSuite(
                name=elem.get('name', 'Unknown'),
                tests=int(elem.get('tests', 0)),
                failures=int(elem.get('failures', 0)),
                errors=int(elem.get('errors', 0)),
                skipped=int(elem.get('skipped', 0)),
                time_seconds=float(elem.get('time', 0))
            )
            
            # Parse test cases
            for testcase_elem in elem.findall('testcase'):
                test_case = self._parse_testcase(testcase_elem)
                if test_case:
                    suite.test_cases.append(test_case)
            
            return suite
            
        except Exception as e:
            logger.error(f"Failed to parse testsuite: {e}")
            return None
    
    def _parse_testcase(self, elem: ET.Element) -> Optional[TestCase]:
        """Parse a testcase element."""
        try:
            name = elem.get('name', 'Unknown')
            classname = elem.get('classname', '')
            duration = float(elem.get('time', 0))
            
            # Determine status from child elements
            status = TestStatus.PASSED
            failure_message = None
            failure_type = None
            stack_trace = None
            
            # Check for failure
            failure_elem = elem.find('failure')
            if failure_elem is not None:
                status = TestStatus.FAILED
                failure_message = failure_elem.get('message', '')
                failure_type = failure_elem.get('type', '')
                stack_trace = failure_elem.text or ''
            
            # Check for error
            error_elem = elem.find('error')
            if error_elem is not None:
                status = TestStatus.ERROR
                failure_message = error_elem.get('message', '')
                failure_type = error_elem.get('type', '')
                stack_trace = error_elem.text or ''
            
            # Check for skipped
            skipped_elem = elem.find('skipped')
            if skipped_elem is not None:
                status = TestStatus.SKIPPED
                failure_message = skipped_elem.get('message', '')
            
            # Get system-out and system-err
            system_out_elem = elem.find('system-out')
            system_out = system_out_elem.text if system_out_elem is not None else None
            
            system_err_elem = elem.find('system-err')
            system_err = system_err_elem.text if system_err_elem is not None else None
            
            return TestCase(
                name=name,
                classname=classname,
                status=status,
                duration_seconds=duration,
                failure_message=failure_message,
                failure_type=failure_type,
                stack_trace=stack_trace,
                system_out=system_out,
                system_err=system_err
            )
            
        except Exception as e:
            logger.error(f"Failed to parse testcase: {e}")
            return None
    
    def get_failed_tests(self, suites: list[TestSuite]) -> list[TestCase]:
        """Extract all failed test cases from suites."""
        failed = []
        for suite in suites:
            for test in suite.test_cases:
                if test.status in (TestStatus.FAILED, TestStatus.ERROR):
                    failed.append(test)
        return failed
    
    def get_test_summary(self, suites: list[TestSuite]) -> dict:
        """Get summary statistics from test suites."""
        total_tests = sum(s.tests for s in suites)
        total_passed = sum(s.passed for s in suites)
        total_failed = sum(s.failures for s in suites)
        total_errors = sum(s.errors for s in suites)
        total_skipped = sum(s.skipped for s in suites)
        total_time = sum(s.time_seconds for s in suites)
        
        return {
            'total_tests': total_tests,
            'passed': total_passed,
            'failed': total_failed,
            'errors': total_errors,
            'skipped': total_skipped,
            'total_time_seconds': total_time,
            'pass_rate': (total_passed / total_tests * 100) if total_tests > 0 else 0
        }
    
    def extract_test_name_components(self, test_name: str) -> dict:
        """
        Extract components from a Kubernetes e2e test name.
        
        Test names follow pattern like:
        "[It] [sig-windows] [Feature:Windows] Memory Limits [Serial] [Slow] should do something"
        
        Returns:
            Dict with 'sig', 'feature', 'tags', 'description'
        """
        components = {
            'sig': None,
            'feature': None,
            'tags': [],
            'description': ''
        }
        
        # Extract SIG
        sig_match = re.search(r'\[sig-([^\]]+)\]', test_name)
        if sig_match:
            components['sig'] = sig_match.group(1)
        
        # Extract Feature
        feature_match = re.search(r'\[Feature:([^\]]+)\]', test_name)
        if feature_match:
            components['feature'] = feature_match.group(1)
        
        # Extract all tags in brackets
        tags = re.findall(r'\[([^\]]+)\]', test_name)
        components['tags'] = [t for t in tags if not t.startswith('sig-') and not t.startswith('Feature:')]
        
        # Extract description (text after last bracket)
        desc_match = re.search(r'\][^\[]*$', test_name)
        if desc_match:
            components['description'] = desc_match.group().lstrip('] ').strip()
        
        return components
    
    def group_failures_by_sig(self, failed_tests: list[TestCase]) -> dict[str, list[TestCase]]:
        """Group failed tests by SIG."""
        groups = {}
        for test in failed_tests:
            components = self.extract_test_name_components(test.name)
            sig = components['sig'] or 'unknown'
            if sig not in groups:
                groups[sig] = []
            groups[sig].append(test)
        return groups
    
    def group_failures_by_feature(self, failed_tests: list[TestCase]) -> dict[str, list[TestCase]]:
        """Group failed tests by Feature."""
        groups = {}
        for test in failed_tests:
            components = self.extract_test_name_components(test.name)
            feature = components['feature'] or 'unknown'
            if feature not in groups:
                groups[feature] = []
            groups[feature].append(test)
        return groups
